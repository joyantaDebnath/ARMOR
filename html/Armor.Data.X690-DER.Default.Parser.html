<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Armor.Data.X690-DER.Default.Parser</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="Armor.Binary.html" class="Module">Armor.Binary</a>
<a id="26" class="Keyword">open</a> <a id="31" class="Keyword">import</a> <a id="38" href="Armor.Data.X690-DER.Default.Properties.html" class="Module">Armor.Data.X690-DER.Default.Properties</a>
<a id="77" class="Keyword">open</a> <a id="82" class="Keyword">import</a> <a id="89" href="Armor.Data.X690-DER.Default.TCB.html" class="Module">Armor.Data.X690-DER.Default.TCB</a>
<a id="121" class="Keyword">import</a>      <a id="133" href="Armor.Grammar.Definitions.html" class="Module">Armor.Grammar.Definitions</a>
<a id="159" class="Keyword">import</a>      <a id="171" href="Armor.Grammar.Option.html" class="Module">Armor.Grammar.Option</a>
<a id="192" class="Keyword">import</a>      <a id="204" href="Armor.Grammar.Parallel.html" class="Module">Armor.Grammar.Parallel</a>
<a id="227" class="Keyword">import</a>      <a id="239" href="Armor.Grammar.Parser.html" class="Module">Armor.Grammar.Parser</a>
<a id="260" class="Keyword">import</a>      <a id="272" href="Armor.Grammar.Seq.html" class="Module">Armor.Grammar.Seq</a>
<a id="290" class="Keyword">open</a> <a id="295" class="Keyword">import</a> <a id="302" href="Armor.Prelude.html" class="Module">Armor.Prelude</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Armor.Data.X690-DER.Default.Parser.html" class="Module">Armor.Data.X690-DER.Default.Parser</a>  <a id="360" class="Keyword">where</a>

<a id="367" class="Keyword">open</a> <a id="372" href="Armor.Grammar.Definitions.html" class="Module">Armor.Grammar.Definitions</a> <a id="398" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a>
<a id="404" class="Keyword">open</a> <a id="409" href="Armor.Grammar.Option.html" class="Module">Armor.Grammar.Option</a>      <a id="435" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a>
<a id="441" class="Keyword">open</a> <a id="446" href="Armor.Grammar.Parallel.html" class="Module">Armor.Grammar.Parallel</a>    <a id="472" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a>
<a id="478" class="Keyword">open</a> <a id="483" href="Armor.Grammar.Parser.html" class="Module">Armor.Grammar.Parser</a>      <a id="509" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a>
<a id="515" class="Keyword">open</a> <a id="520" href="Armor.Grammar.Seq.html" class="Module">Armor.Grammar.Seq</a>         <a id="546" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a>

<a id="553" class="Keyword">module</a> <a id="560" href="Armor.Data.X690-DER.Default.Parser.html#560" class="Module">_</a> <a id="562" class="Symbol">{</a><a id="563" href="Armor.Data.X690-DER.Default.Parser.html#563" class="Bound">A</a> <a id="565" class="Symbol">:</a> <a id="567" class="Symbol">@</a><a id="568" class="Symbol">0</a> <a id="570" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="575" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a> <a id="581" class="Symbol">→</a> <a id="583" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="586" class="Symbol">}</a> <a id="588" class="Symbol">⦃</a> <a id="590" href="Armor.Data.X690-DER.Default.Parser.html#590" class="Bound">eq≋</a> <a id="594" class="Symbol">:</a> <a id="596" href="Armor.Grammar.Definitions.Eq.html#1243" class="Record">Eq≋</a> <a id="600" href="Armor.Data.X690-DER.Default.Parser.html#563" class="Bound">A</a> <a id="602" class="Symbol">⦄</a> <a id="604" class="Symbol">{@</a><a id="606" class="Symbol">0</a> <a id="608" href="Armor.Data.X690-DER.Default.Parser.html#608" class="Bound">bs&#39;</a> <a id="612" class="Symbol">:</a> <a id="614" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="619" href="Armor.Binary.UInt8.TCB.html#158" class="Function">UInt8</a><a id="624" class="Symbol">}</a> <a id="626" class="Symbol">(</a><a id="627" href="Armor.Data.X690-DER.Default.Parser.html#627" class="Bound">default</a> <a id="635" class="Symbol">:</a> <a id="637" href="Armor.Data.X690-DER.Default.Parser.html#563" class="Bound">A</a> <a id="639" href="Armor.Data.X690-DER.Default.Parser.html#608" class="Bound">bs&#39;</a><a id="642" class="Symbol">)</a> <a id="644" class="Symbol">(</a><a id="645" href="Armor.Data.X690-DER.Default.Parser.html#645" class="Bound">loc</a> <a id="649" class="Symbol">:</a> <a id="651" href="Armor.Prelude.html#3078" class="Function">String</a><a id="657" class="Symbol">)</a> <a id="659" class="Keyword">where</a>
  <a id="667" class="Comment">-- parse : Unambiguous A → NoSubstrings A → Parser (Logging ∘ Dec) A → Parser (Logging ∘ Dec) (Default A default)</a>
  <a id="783" class="Comment">-- runParser (parse ua ns p) xs = do</a>
  <a id="822" class="Comment">--   yes x ← runParser </a>
  <a id="848" class="Comment">--   {!!}</a>

  <a id="861" class="Comment">-- parse₁&amp;₁≤</a>
  <a id="876" class="Comment">--   : ∀ {@ 0 B : @0 List UInt8 → Set} n → Parser (Logging ∘ Dec) A → Parser (Logging ∘ Dec) B</a>
  <a id="973" class="Comment">--     → @0 NoSubstrings A → @0 Unambiguous A → @0 NoSubstrings B → @0 NoConfusion A B</a>
  <a id="1062" class="Comment">--     → Parser (Logging ∘ Dec) (Length≤ (&amp;ₚ (Default A default) B) n)</a>
  <a id="1135" class="Comment">-- runParser (parse₁&amp;₁≤ n p₁ p₂ nn₁ ua₁ nn₂ nc) xs = do</a>
  <a id="1193" class="Comment">--   (yes (success pre₁ r₁ r₁≡ (mk×ₚ (mk&amp;ₚ{pre₁₁}{pre₁₂} v₁₁ v₁₂ refl) v₁Len) suf₁ ps≡₁))</a>
  <a id="1285" class="Comment">--     ← runParser (Option.parseOption₁&amp;₁≤ p₁ p₂ nn₁ nn₂ nc (tell $ loc String.++ &quot;: length overflow&quot;) n) xs</a>
  <a id="1396" class="Comment">--     where no ¬parse → do</a>
  <a id="1426" class="Comment">--       tell $ loc String.++ &quot;: failed to parse [default]&quot;</a>
  <a id="1488" class="Comment">--       return ∘ no $ λ where</a>
  <a id="1521" class="Comment">--         (success prefix read read≡ (mk×ₚ (mk&amp;ₚ v₁₁ v₁₂ refl) v₁Len) suffix ps≡) →</a>
  <a id="1608" class="Comment">--           contradiction</a>
  <a id="1637" class="Comment">--             (success prefix read read≡ (mk×ₚ (mk&amp;ₚ (Default.value v₁₁) v₁₂ refl) v₁Len) suffix ps≡)</a>
  <a id="1742" class="Comment">--             ¬parse</a>
  <a id="1766" class="Comment">--   case (singleton v₁₁ refl) ret (const _) of λ where</a>
  <a id="1824" class="Comment">--     (singleton none refl) →</a>
  <a id="1857" class="Comment">--       return (yes</a>
  <a id="1880" class="Comment">--         (success pre₁ r₁ r₁≡ (mk×ₚ (mk&amp;ₚ (mkDefault none tt) v₁₂ refl) v₁Len) suf₁ ps≡₁))</a>
  <a id="1975" class="Comment">--     (singleton (some v₁₁&#39;) refl) → case (_≋?_{A = A} v₁₁&#39; default) ret (const _) of λ where</a>
  <a id="2072" class="Comment">--       (no ¬p) → return (yes</a>
  <a id="2105" class="Comment">--         (success pre₁ r₁ r₁≡</a>
  <a id="2139" class="Comment">--           (mk×ₚ (mk&amp;ₚ (mkDefault (some v₁₁&#39;) (fromWitnessFalse{Q = _ ≋? _} ¬p)) v₁₂ refl) v₁Len)</a>
  <a id="2241" class="Comment">--           _ ps≡₁))</a>
  <a id="2265" class="Comment">--       (yes p) → do</a>
  <a id="2289" class="Comment">--         tell $ loc String.++ &quot;: default value present!&quot;</a>
  <a id="2350" class="Comment">--         return ∘ no $ λ where</a>
  <a id="2385" class="Comment">--           (success prefix read read≡ (mk×ₚ (mk&amp;ₚ{prefix₁}{prefix₂} (mkDefault none notDefault) value₂ refl) valueLen) suffix ps≡) →</a>
  <a id="2522" class="Comment">--             let</a>
  <a id="2543" class="Comment">--               @0 ++≡ : pre₁₁ ++ (pre₁₂ ++ suf₁) ≡ prefix ++ suffix</a>
  <a id="2615" class="Comment">--               ++≡ = begin</a>
  <a id="2646" class="Comment">--                 pre₁₁ ++ (pre₁₂ ++ suf₁) ≡⟨ sym (++-assoc pre₁₁ pre₁₂ suf₁) ⟩</a>
  <a id="2729" class="Comment">--                 (pre₁₁ ++ pre₁₂) ++ suf₁ ≡⟨ ps≡₁ ⟩</a>
  <a id="2785" class="Comment">--                 xs ≡⟨ sym ps≡ ⟩</a>
  <a id="2822" class="Comment">--                 prefix ++ suffix ∎</a>
  <a id="2862" class="Comment">--             in</a>
  <a id="2882" class="Comment">--             contradiction</a>
  <a id="2913" class="Comment">--               value₂</a>
  <a id="2939" class="Comment">--               (nc ++≡ v₁₁&#39;)</a>
  <a id="2972" class="Comment">--           (success prefix read read≡ (mk×ₚ (mk&amp;ₚ{prefix₁}{prefix₂} (mkDefault (some value₁) notDefault) value₂ refl) valueLen) suffix ps≡) →</a>
  <a id="3118" class="Comment">--             let</a>
  <a id="3139" class="Comment">--               @0 ++≡ : prefix₁ ++ prefix₂ ++ suffix ≡ pre₁₁ ++ pre₁₂ ++ suf₁</a>
  <a id="3221" class="Comment">--               ++≡ = begin</a>
  <a id="3252" class="Comment">--                 prefix₁ ++ prefix₂ ++ suffix ≡⟨ sym (++-assoc prefix₁ prefix₂ suffix) ⟩</a>
  <a id="3345" class="Comment">--                 (prefix₁ ++ prefix₂) ++ suffix ≡⟨ ps≡ ⟩</a>
  <a id="3406" class="Comment">--                 xs ≡⟨ sym ps≡₁ ⟩</a>
  <a id="3444" class="Comment">--                 (pre₁₁ ++ pre₁₂) ++ suf₁ ≡⟨ ++-assoc pre₁₁ pre₁₂ suf₁ ⟩</a>
  <a id="3521" class="Comment">--                 pre₁₁ ++ pre₁₂ ++ suf₁ ∎</a>

  <a id="3568" class="Comment">--               @0 prefix₁≡ : prefix₁ ≡ pre₁₁</a>
  <a id="3617" class="Comment">--               prefix₁≡ = nn₁ ++≡ value₁ v₁₁&#39;</a>

  <a id="3668" class="Comment">--               @0 value₁≋ : value₁ ≋ v₁₁&#39;</a>
  <a id="3714" class="Comment">--               value₁≋ = mk≋ prefix₁≡ (case prefix₁≡ ret (λ x → subst A x value₁ ≡ v₁₁&#39;) of λ where</a>
  <a id="3818" class="Comment">--                 refl → ‼ ua₁ value₁ v₁₁&#39;)</a>
  <a id="3865" class="Comment">--             in</a>
  <a id="3885" class="Comment">--             contradiction</a>
  <a id="3916" class="Comment">--               (trans≋ value₁≋ p)</a>
  <a id="3954" class="Comment">--               (toWitnessFalse notDefault)</a>
  <a id="4001" class="Comment">--   where</a>
  <a id="4014" class="Comment">--   open ≡-Reasoning</a>
</pre></body></html>