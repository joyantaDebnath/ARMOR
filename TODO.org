#+TITLE: AERES Project Management

* PROJ AERES Project Status                                            :work:
  :PROPERTIES:
  :CATEGORY: Aeres
  :NOBLOCKING: t
  :toggl-project: Aeres
  :END:
** Cryptography
   - Note taken on [2022-02-11 Fri 12:38] \\
     After a discussion, it was decided we will outsource cryptographic checks,
     invoking Aeres from a harness

   In order to perform differential testing, AERES or a harness for AERES needs
   to be able check that a digest was signed by the a given public key. There are
   no cryptographic libraries for Agda (that we know of), so we have considered
   the following options.

   1. [ ] Use Agda's Haskell FFI to connect Aeres to [[https://hackage.haskell.org/package/crypto-sodium][crypto-sodium]], a Haskell
      crypto library

   2. [ ] Use Agda's Haskell FFI to connect Aeres to Haskell, then use Haskell's
      FFI to connect to EverCrypt (or another formally verified crypto library)

   3. [X] Have Aeres return as output remaining cryptographic / PKCS checks to
      check, and use a harness to invoke EverCrypt / HaCL* / Vale (for just
      cryptographic checks) or [[https://github.com/Morpheus-Repo/Morpheus][Morpehus]] (for full PKCS checks)

** General
*** DONE Make AERES executable run semantic checks                    :@code:
    CLOSED: [2022-12-07 Wed 21:07]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-12-07 Wed 21:07]
*** WONT [1/2] Review semantic checks                                 :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "NEXT"       from "TODO"       [2023-02-07 Tue 17:14]
    - Note taken on [2023-02-07 Tue 17:14] \\
      It's fine for now, just note which semantic checks are high confidence and which
      are not.
**** TODO Review CCP7 from spec                                       :@code:
     :PROPERTIES:
     :ASSIGNEE: Joy
     :END:
**** DONE Update SCP18 to use total ordering for time                 :@code:
     CLOSED: [2023-10-23 Mon 11:05]
     :PROPERTIES:
     :ASSIGNEE: Christa
     :END:
     - State "DONE"       from "TODO"       [2023-10-23 Mon 11:05] \\
       A total ordering of time (lexicographic) has been established, and comparison of
       times is based on that (after converting two digit years to four digit years,
       according to the specification)
*** DONE Change Int specification                                     :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    This came up when we realized we needed a serializer for parsing public key
    fields. The previous specification for IntegerValue made serialization
    difficult. For now, the representation of integer values is the literal byte
    string (this can and probably should change in the future)
*** DONE Accept and parse root store, check membership                :@code:
    CLOSED: [2023-09-01 Fri 10:34]
    - State "DONE"       from "TODO"       [2023-09-01 Fri 10:34]
*** TODO [#C] Bounded look-ahead sum                                  :@code:
    :LOGBOOK:
    CLOCK: [2023-09-11 Mon 15:15]--[2023-09-11 Mon 16:15] =>  1:00
    :END:
*** DONE [#A] Fix RDN specification                                   :@code:
    CLOSED: [2023-09-18 Mon 11:59]
    - State "DONE"       from "TODO"       [2023-09-18 Mon 11:59]
    :LOGBOOK:
    CLOCK: [2023-09-13 Wed 09:35]--[2023-09-13 Wed 10:35] =>  1:00
    CLOCK: [2023-09-12 Tue 13:05]--[2023-09-12 Tue 16:05] =>  3:00
    CLOCK: [2023-09-12 Tue 10:00]--[2023-09-12 Tue 12:00] =>  2:00
    :END:
*** DONE [#A] Time and validity correctness                           :@code:
    CLOSED: [2023-10-23 Mon 11:08]
    - State "DONE"       from "TODO"       [2023-10-23 Mon 11:08]
    :LOGBOOK:
    CLOCK: [2023-10-06 Fri 09:50]--[2023-10-06 Fri 18:00] =>  8:10
    CLOCK: [2023-10-06 Fri 09:05]--[2023-10-06 Fri 10:05] =>  1:00
    :END:
*** DONE Add SetOf specification                                      :@code:
    CLOSED: [2023-10-23 Mon 11:07]
    - State "DONE"       from "TODO"       [2023-10-23 Mon 11:07] \\
      Added, and RDN has been converted to use SetOf
    :LOGBOOK:
    CLOCK: [2023-10-20 Fri 11:05]--[2023-10-20 Fri 15:00] =>  3:55
    :END:
*** DONE Support DEFAULT encodings                                    :@code:
    CLOSED: [2023-10-30 Mon 09:40]

    - State "DONE"       from "TODO"       [2023-10-30 Mon 09:40]
** Non-malleability
*** DONE Define injective spec -> data maps                           :@code:
    CLOSED: [2023-10-23 Mon 11:07]
    - State "DONE"       from "TODO"       [2023-10-23 Mon 11:07] \\
      Nonmalleability proven for everything up to certificate chains!
    :LOGBOOK:
    CLOCK: [2023-10-15 Sun 08:00]--[2023-10-15 Sun 14:30] =>  6:30
    CLOCK: [2023-10-05 Thu 08:50]--[2023-10-05 Thu 17:00] =>  8:10
    CLOCK: [2023-10-03 Tue 09:00]--[2023-10-03 Tue 16:40] =>  7:40
    CLOCK: [2023-09-27 Wed 11:45]--[2023-09-27 Wed 17:00] =>  5:15
    CLOCK: [2023-09-26 Tue 15:25]--[2023-09-26 Tue 18:25] =>  3:00
    CLOCK: [2023-09-21 Thu 08:30]--[2023-09-21 Thu 09:30] =>  1:00
    CLOCK: [2023-09-19 Tue 15:20]--[2023-09-19 Tue 18:00] =>  2:40
    CLOCK: [2023-09-18 Mon 13:50]--[2023-09-18 Mon 17:00] =>  3:10
    :END:
    - Note taken on [2023-09-16 Sat 09:51] \\
      It is important to note that the meaningfulness of the injectiveness part of
      nonmalleability property rests on the choice of the "raw" representation. We
      are defining injectivity here wrt a nonindexed datatype we map into, where that
      datatypes is meant to represent the purely computational component of the
      structure. But, it is easy to "cheat" at this, by an identity map into Exists---
      (List UInt8) A, which keeps all the specificational components. Thus, one
      potential weakeness (but also "challenge") is capturing the *two* specifications correctly.
    - Note taken on [2023-08-15 Tue 13:22] \\
      Non-malleable means:
      - /unique:/ there is only one value /v/ to be read from a bytestring /bs/
        This is already handled by the proofs that the grammar is /Unique/
      - /injective:/ should /v1/ be encoded by /bs1/, and /v2/ encoded by /bs/, and
        /v1 = v2/, then /bs1 = bs2/
      
      
      Currently, we can't state injectiveness because the specification includes the
      bytestring as part of the type. So, we need a non-indexed version of "value" so
      we can state this second part of /malleable/.
*** TODO Sharpen raw representation of OID                            :@code:

    - Note taken on [2023-09-18 Mon 15:18] \\
      We are going to go forward with a raw representation of OIDs as List (List
      UInt8) since we only ever compare encodings to encodings. This is pretty cheap,
      as what one might really care about is the *decoded* values read. But that
      involves a lot of work!
      
      - ensuring that there are only 3 arcs from the root
      - generalizing unsigned to work with arbitrary powers of 2 (because the OIDSub
        values are really packed into base 128, with the leading bit just telling you
        whether this is the end of encoding the present value)
      - proving this generalization is injective!
** Total Correctness

   Ideally, all {-# TERMINATING #-} pragmas should be removed. I (Christa)
   believe the ones that call into question whether the /parser itself/ (rather
   than the runtime-irrelevant proofs) should be prioritized.
*** DONE Remove termination pragmas in the executable code            :@code:
    CLOSED: [2023-09-18 Mon 11:59]
    - State "DONE"       from "TODO"       [2023-09-18 Mon 11:59]
    :LOGBOOK:
    CLOCK: [2023-09-07 Thu 10:10]--[2023-09-07 Thu 13:15] =>  1:50
    CLOCK: [2023-09-05 Tue 09:55]--[2023-09-05 Tue 11:15] =>  1:20
    CLOCK: [2023-09-03 Sun 15:30]--[2023-09-03 Sun 17:00] =>  0:45
    CLOCK: [2023-09-01 Fri 14:10]--[2023-09-01 Fri 14:30] =>  0:20
    CLOCK: [2023-09-01 Fri 13:30]--[2023-09-01 Fri 14:05] =>  0:35
    :END:
*** DONE Remove all remaining termination pragmas                     :@code:
    CLOSED: [2023-09-18 Mon 11:59]

    - State "DONE"       from "TODO"       [2023-09-18 Mon 11:59]
** Chain Building
    - Note taken on [2022-05-03 Tue 16:07] \\
      Was not truly finished --- requires parsing PEM first, then decoding.

      And then this requires proper parsing of base64
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]


    Sequence of tasks:
    1. Parse PEM (valid character set, length divisible by 4, padding)
       Requires Base64 parser
    2. Unverified conversion to byte string
       To be verified later?
    3. Parse X509 cert
   
*** DONE Parse Base64                                                 :@code:
    CLOSED: [2022-07-08 Fri 17:09]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-07-08 Fri 17:09] \\
      Finished, with some tests. There is now particular care taken to the last
      character of a B64 quartet that includes padding
    - Note taken on [2022-06-10 Fri 15:01] \\
      Had to return to base64 parsing because the spec was not quite right (too lax
      when it comes to input whose bit length is not a multiple of 24)
    - State "DONE"       from "TODO"       [2022-06-02 Thu 17:24]
*** DONE [#A] Parse PEM                                               :@code:
    CLOSED: [2023-09-01 Fri 10:33]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2023-09-01 Fri 10:33]
    - Note taken on [2022-08-28 Sun 19:08] \\
      <2022-08-29 Mon 12:00>
    - Note taken on [2022-08-28 Sun 19:06] \\
      <2022-08-29 Mon 18:00>
    - Note taken on [2022-08-28 Sun 19:06] \\
      <2022-08-29 Mon 13:00>
**** DONE Finish PEM property postulates
     CLOSED: [2022-12-07 Wed 21:07]
     - State "DONE"       from "TODO"       [2022-12-07 Wed 21:07]
*** DONE [#A] Fix strings specification                               :@code:
    CLOSED: [2023-09-18 Mon 11:59]
    - State "DONE"       from "TODO"       [2023-09-18 Mon 11:59]
    - Note taken on [2023-09-08 Fri 10:15] \\
      The length bounds for DisplayText don't appear to be correct... at least,
      we have found a cert that is longer than 200 bytes (because it uses UTF16
      encoding) 
    - State "DONE"       from "TODO"       [2023-09-08 Fri 08:55] \\
      Finished for now, though we don't support full UTF16
    :LOGBOOK:
    CLOCK: [2023-09-08 Fri 09:30]--[2023-09-08 Fri 13:30] =>  4:00
    CLOCK: [2023-09-05 Tue 15:30]--[2023-09-05 Tue 17:15] =>  1:45
    CLOCK: [2023-09-03 Sun 09:00]--[2023-09-03 Sun 13:25] =>  4:25
    :END:

    - Note taken on [2023-09-03 Sun 11:25] \\
      We discovered that BMP, universal, and other string types were not implemented
      correctly. The assumption was that these were UTF8, but they they were actually
      UTF16 and UTF32
** Cert parsing
*** DONE Parse public key extensions                                  :@code:
    CLOSED: [2022-07-11 Mon 17:54]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:
    - State "DONE"       from "TODO"       [2022-07-11 Mon 17:54]
**** DONE Lemmas for public key extensions parser                     :@code:
     CLOSED: [2022-07-11 Mon 17:54]
     :PROPERTIES:
     :ASSIGNEE: Christa
     :END:
     - State "DONE"       from "TODO"       [2022-07-11 Mon 17:54]
     - Note taken on [2022-06-14 Tue 18:29] \\
       Need to be able to use the OID parser to show that a literal (for RSA PK
       algorithm) is a valid OID. For that, need to move TLV, Length properties to
       avoid cyclic module dependency
** StringPrep
*** WONT Analyze cert. census data for language (unicode)             :@code:
    CLOSED: [2022-06-02 Thu 17:23]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:
    - State "WONT"       from "TODO"       [2022-06-02 Thu 17:23]
    - Note taken on [2022-04-15 Fri 15:41] \\
      Do we need this? Switched focus to case folding, which already does
      normalization for large set of characters already.
      So the info we are pulling from comes from the [[https://datatracker.ietf.org/doc/html/rfc3454#appendix-B.2][RFC]] instead

    We are not planning on supporting /all/ languages supported by Unicode, so
    lets find a subset that covers most / all of our testing data
*** WONT String normalization code generation                         :@code:
    CLOSED: [2022-04-15 Fri 14:40]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:

    - State "WONT"       from "TODO"       [2022-04-15 Fri 14:40] \\
      We will use actual tries instead, hoping this will improve performance for
      typechecking and runtime
    Per discussion with Omar, having a function with "trie-like" cases might
    speed up runtime by sharing lookup, and compile time by reducing the number
    of cases
*** MAYBE Custom ordering for UTF8Char                                :@code:
    CLOSED: [2022-06-02 Thu 18:33]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    A custom ordering for UTF8Char may be needed if comparisons (needed for
    checking if a code lands within a certain range) are too slow.

    If we use an ordering other than the obvious translation to Nat, then we
    will want to prove, at least, that it is a total order.
    Probably we also want to prove it coincides with the obvious ordering
*** DONE Define UTF8 spec                                             :@code:
    CLOSED: [2022-03-22 Tue 13:17]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]
*** MAYBE Prove StringPrep algorithm is idempotent                    :@code:
    CLOSED: [2023-09-18 Mon 11:59]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "MAYBE"      from "TODO"       [2023-09-18 Mon 11:59] \\
      Not a priority at this time
*** DONE Decidable equality for =Unicode=                             :@code:
    CLOSED: [2023-09-08 Fri 08:55]
    - State "DONE"       from "TODO"       [2023-09-08 Fri 08:55] \\
      Finished for now, though we don't support full UTF16
    :LOGBOOK:
    CLOCK: [2023-09-05 Tue 11:15]--[2023-09-05 Tue 12:00] =>  0:45
    :END:
** Presentation
  
*** TODO Note =--sized-types= =--guardedness= inconsistency        :@typeset:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

   See the remark in the documentation [[https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html][here]], and the filed issue [[https://github.com/agda/agda/issues/1209][here]].

   - We only use sized types for the agda-stdlib trie implementation, and
     guardedness for the agda-stdlib IO implementation. We do not mixed guarded
     coinductive and sized inductive types, so the issue should not apply to us.

     That said, since sized types are broken on their own, the ideal solution is
     to roll our own trie implementation.
   
*** DONE Rename grammar properties                                    :@code:
    CLOSED: [2023-10-23 Mon 11:08]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    - State "DONE"       from "TODO"       [2023-10-23 Mon 11:08] \\
      NonNesting -> NoSubstrings
    The names of properties for the grammar elements should, where possible, be
    named following existing literature on languages.

    | Old name      | New name      |
    |---------------+---------------|
    | =NoConfusion= | =NoConflict=  |
    | =Unambiguous= | =Unique=      |
    | =NonEmpty=    |               |
    | =NonNesting=  | =Unambiguous= |
    |---------------+---------------|
    | =Dig=         | =UInt8=       |

*** TODO Remove postulates, =--allow-unsolved-metas=                  :@code:

*** WONT Implement Set uniqueness constraints, or note                :@code:
    CLOSED: [2023-10-23 Mon 11:09]

    - State "WONT"       from "TODO"       [2023-10-23 Mon 11:09] \\
      SetOf and Set have no uniqueness constraints!
    - Note taken on [2023-10-06 Fri 15:54] \\
      We don't implement uniqueness constraints... yet
*** DONE [#A] Write-up explanation of Aeres architecture              :@code:
    CLOSED: [2023-09-01 Fri 10:33]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    - State "DONE"       from "TODO"       [2023-09-01 Fri 10:33]
** Building and running
*** TODO Move tests to their own directory                            :@code:

    This will also speed-up typechecking and compilation time during development
*** TODO [#A] Update main to test all candidate chains                :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    - Note taken on [2023-09-11 Mon 14:27] \\
      Joy is doing chain building in Agda, and would like Aeres to run the chain
      checks on every candidate chain.
* PROJ AERES Paper
** [2/5] Christa

   - [ ] Double-check S3.1.1
   - [ ] Double-check S3.3.6
   - [ ] Finish S4.3 revisions
   - [X] Double-check termination
   - [X] [2/2] ASN1STAR
     - [X] check accuracy of claim that ASN1Star proves mutual correctness wrt
       encoder / decoder
     - [X] contrast unambiguous and uniqueness with non-malleability

       This is not nearly as strong as the non-malleability property of ASN1*,
       because our specifications are not equipped to even *state* the property
       that different bytestring representations of ASN.1 are equal (because the
       bytestring is part of the type, and to even state the property that two
       terms are equal they must have the same type).

       What would have to be done is either make separate, non-indexed datatypes
       capturing the "mere data", write functions that convert the indexed
       specification to the mere data, and prove non-malleability for the
       results (or the mere data could be fields, and we can use lenses)

* Misc Notes

*** 2023 Oct 16 Mon 11:38

    Some confusion about the encoding of RSA PSS: what does DEFAULT apply to?
    #+begin_example
      id-RSASSA-PSS  OBJECT IDENTIFIER  ::=  { pkcs-1 10 }

      RSASSA-PSS-params  ::=  SEQUENCE  {
         hashAlgorithm      [0] HashAlgorithm DEFAULT
                                   sha1Identifier,
         maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
                                   mgf1SHA1Identifier,
         saltLength         [2] INTEGER DEFAULT 20,
         trailerField       [3] INTEGER DEFAULT 1  }
    #+end_example
    
*** 2022 May 31 Tue 20:33

    - serializer for OID, for getSignAlgBS
    - nonnesting for PkAlg
    - postulated public key fields properties

*** 2022 Apr 15 Fri

    - Semantic Checks
      - We should review the specification and proof of each semantic check, to
        make sure that the spec is convincing

        For example
        - SCP18: The check on time just uses booleans, rather than defining an ordering
          on time values
        - CCP7: whether a cert is in a given set (with stringprep)
    - Executable
      - Testing for performance, parsing PEM
      - Returing the remaining crypto checks: PK, Digest, Signature

        For the harness to invoke on an external program
    - Spec improvements
      - Time
        Not as precisely specified as it could be (e.g., leap days, leap seconds
        not covered --- also day ranges for months is inaccurate)
    - String prep
      - It seems to me like idempotency / normalization is the only thing people
        would care about when it comes to the stringprep algorithm

        Its purpose is to give a decidable equivalence relation by giving every
        string a canonical form. If the spec introduces nondeterminism, we are
        no longer formalizing the stringprep algorithm

        To ease reasoning, we can also use lemmas stating no character in the
        image of one mapping is in the domain of a previous mapping
    - Cryptographic checks
      Outsourced to a harness
      - I need to know (from Joy, Omar) what fields need to be checked: for a
        cert, where is the digest, where is the public key
    - Org
      - Joy: update the TODO items that have been assigned to you with the
        results (e.g., analysis of cert data for unicode coverage)

*** 2023 Sep 11 Mon 13:51

    *Challenges:* RDNs may include email addresses, encoded as IA5 strings, but
    the specification for string prep (comparing issuer and subject names) is
    not clear on how to handle anything that falls outside of the
    DirectoryString type

* End

#  LocalWords:  AERES

# Local Variables:
# eval: (flyspell-mode)
# eval: (smartparens-mode)
# End:
