#+TITLE: AERES Project Management

* AERES Project Status                                                 :work:
** Cryptography
   - Note taken on [2022-02-11 Fri 12:38] \\
     After a discussion, it was decided we will outsource cryptographic checks,
     invoking Aeres from a harness

   In order to perform differential testing, AERES or a harness for AERES needs
   to be able check that a digest was signed by the a given public key. There are
   no cryptographic libraries for Agda (that we know of), so we have considered
   the following options.

   1. [ ] Use Agda's Haskell FFI to connect Aeres to [[https://hackage.haskell.org/package/crypto-sodium][crypto-sodium]], a Haskell
      crypto library

   2. [ ] Use Agda's Haskell FFI to connect Aeres to Haskell, then use Haskell's
      FFI to connect to EverCrypt (or another formally verified crypto library)

   3. [X] Have Aeres return as output remaining cryptographic / PKCS checks to
      check, and use a harness to invoke EverCrypt / HaCL* / Vale (for just
      cryptographic checks) or [[https://github.com/Morpheus-Repo/Morpheus][Morpehus]] (for full PKCS checks)

** General
*** TODO Make AERES executable run semantic checks                    :@code:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:
*** TODO [0/2] Review semantic checks                                 :@code:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:
**** TODO Review CCP7 from spec                                       :@code:
     :PROPERTIES:
     :Assignee: Joy
     :END:
**** TODO Update SCP18 to use total ordering for time                 :@code:
     :PROPERTIES:
     :ASSIGNEE: Chris
     :END:
*** TODO Implement chain building                                     :@code:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:
    - Note taken on [2022-05-03 Tue 16:07] \\
      Was not truly finished --- requires parsing PEM first, then decoding.
      
      And then this requires proper parsing of base64
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]
** StringPrep
*** TODO Analyze cert. census data for language (unicode)             :@code:
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:
    - Note taken on [2022-04-15 Fri 15:41] \\
      Do we need this? Switched focus to case folding, which already does
      normalization for large set of characters already.
      So the info we are pulling from comes from the [[https://datatracker.ietf.org/doc/html/rfc3454#appendix-B.2][RFC]] instead

    We are not planning on supporting /all/ languages supported by Unicode, so
    lets find a subset that covers most / all of our testing data
*** WONT String normalization code generation                         :@code:
    CLOSED: [2022-04-15 Fri 14:40]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:

    - State "WONT"       from "TODO"       [2022-04-15 Fri 14:40] \\
      We will use actual tries instead, hoping this will improve performance for
      typechecking and runtime
    Per discussion with Omar, having a function with "trie-like" cases might
    speed up runtime by sharing lookup, and compile time by reducing the number
    of cases
*** TODO Ordering for UTF8Char                                        :@code:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:

    If we use an ordering other than the obvious translation to Nat, then we
    will want to prove it is a total order
*** DONE Define UTF8 spec                                             :@code:
    CLOSED: [2022-03-22 Tue 13:17]
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]
** Presentation
  
*** TODO Note =--sized-types= =--guardedness= inconsistency        :@typeset:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:

   See the remark in the documentation [[https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html][here]], and the filed issue [[https://github.com/agda/agda/issues/1209][here]].

   - We only use sized types for the agda-stdlib trie implementation, and
     guardedness for the agda-stdlib IO implementation. We do not mixed guarded
     coinductive and sized inductive types, so the issue should not apply to us.

     That said, since sized types are broken on their own, the ideal solution is
     to roll our own trie implementation.
   
*** TODO Rename grammar properties                                    :@code:
    :PROPERTIES:
    :ASSIGNEE: Chris
    :END:

    The names of properties for the grammar elements should, where possible, be
    named following existing literature on languages.

    | Old name      | New name      |
    |---------------+---------------|
    | =NoConfusion= | =NoConflict=  |
    | =Unambiguous= | =Unique=      |
    | =NonEmpty=    |               |
    | =NonNesting=  | =Unambiguous= |
    |---------------+---------------|
    | =Dig=         | =UInt8=       |

*** TODO Remove postulates, =--allow-unsolved-metas=                  :@code:

** Building and running
*** TODO Move tests to their own directory                            :@code:

    This will also speed-up typechecking and compilation time during development
* Misc Notes

*** 2022 May 31 Tue 20:33

    - serializer for OID, for getSignAlgBS
    - nonnesting for PkAlg
    - postulated public key fields properties

*** 2022 Apr 15 Fri

    - Semantic Checks
      - We should review the specification and proof of each semantic check, to
        make sure that the spec is convincing

        For example
        - SCP18: The check on time just uses booleans, rather than defining an ordering
          on time values
        - CCP7: whether a cert is in a given set (with stringprep)
    - Executable
      - Testing for performance, parsing PEM
      - Returing the remaining crypto checks: PK, Digest, Signature

        For the harness to invoke on an external program
    - Spec improvements
      - Time
        Not as precisely specified as it could be (e.g., leap days, leap seconds
        not covered --- also day ranges for months is inaccurate)
    - String prep
      - It seems to me like idempotency / normalization is the only thing people
        would care about when it comes to the stringprep algorithm

        Its purpose is to give a decidable equivalence relation by giving every
        string a canonical form. If the spec introduces nondeterminism, we are
        no longer formalizing the stringprep algorithm

        To ease reasoning, we can also use lemmas stating no character in the
        image of one mapping is in the domain of a previous mapping
    - Cryptographic checks
      Outsourced to a harness
      - I need to know (from Joy, Omar) what fields need to be checked: for a
        cert, where is the digest, where is the public key
    - Org
      - Joy: update the TODO items that have been assigned to you with the
        results (e.g., analysis of cert data for unicode coverage)
* End

#  LocalWords:  AERES

# Local Variables:
# eval: (flyspell-mode)
# eval: (smartparens-mode)
# End:
