#+TITLE: AERES Project Management

* PROJ AERES Project Status                                            :work:
  :PROPERTIES:
  :CATEGORY: Aeres
  :NOBLOCKING: t
  :END:
** Cryptography
   - Note taken on [2022-02-11 Fri 12:38] \\
     After a discussion, it was decided we will outsource cryptographic checks,
     invoking Aeres from a harness

   In order to perform differential testing, AERES or a harness for AERES needs
   to be able check that a digest was signed by the a given public key. There are
   no cryptographic libraries for Agda (that we know of), so we have considered
   the following options.

   1. [ ] Use Agda's Haskell FFI to connect Aeres to [[https://hackage.haskell.org/package/crypto-sodium][crypto-sodium]], a Haskell
      crypto library

   2. [ ] Use Agda's Haskell FFI to connect Aeres to Haskell, then use Haskell's
      FFI to connect to EverCrypt (or another formally verified crypto library)

   3. [X] Have Aeres return as output remaining cryptographic / PKCS checks to
      check, and use a harness to invoke EverCrypt / HaCL* / Vale (for just
      cryptographic checks) or [[https://github.com/Morpheus-Repo/Morpheus][Morpehus]] (for full PKCS checks)

** General
*** DONE Make AERES executable run semantic checks                    :@code:
    CLOSED: [2022-12-07 Wed 21:07]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-12-07 Wed 21:07]
*** WONT [0/2] Review semantic checks                                 :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "NEXT"       from "TODO"       [2023-02-07 Tue 17:14]
    - Note taken on [2023-02-07 Tue 17:14] \\
      It's fine for now, just note which semantic checks are high confidence and which
      are not.
**** TODO Review CCP7 from spec                                       :@code:
     :PROPERTIES:
     :ASSIGNEE: Joy
     :END:
**** TODO Update SCP18 to use total ordering for time                 :@code:
     :PROPERTIES:
     :ASSIGNEE: Christa
     :END:
*** DONE Change Int specification                                     :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    This came up when we realized we needed a serializer for parsing public key
    fields. The previous specification for IntegerValue made serialization
    difficult. For now, the representation of integer values is the literal byte
    string (this can and probably should change in the future)
*** TODO Accept and parse root store, check membership                :@code:

** Chain Building
    - Note taken on [2022-05-03 Tue 16:07] \\
      Was not truly finished --- requires parsing PEM first, then decoding.

      And then this requires proper parsing of base64
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]


    Sequence of tasks:
    1. Parse PEM (valid character set, length divisible by 4, padding)
       Requires Base64 parser
    2. Unverified conversion to byte string
       To be verified later?
    3. Parse X509 cert
   
*** DONE Parse Base64                                                 :@code:
    CLOSED: [2022-07-08 Fri 17:09]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-07-08 Fri 17:09] \\
      Finished, with some tests. There is now particular care taken to the last
      character of a B64 quartet that includes padding
    - Note taken on [2022-06-10 Fri 15:01] \\
      Had to return to base64 parsing because the spec was not quite right (too lax
      when it comes to input whose bit length is not a multiple of 24)
    - State "DONE"       from "TODO"       [2022-06-02 Thu 17:24]
*** TODO [#A] Parse PEM                                               :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - Note taken on [2022-08-28 Sun 19:08] \\
      <2022-08-29 Mon 12:00>
    - Note taken on [2022-08-28 Sun 19:06] \\
      <2022-08-29 Mon 18:00>
    - Note taken on [2022-08-28 Sun 19:06] \\
      <2022-08-29 Mon 13:00>
**** DONE Finish PEM property postulates
     CLOSED: [2022-12-07 Wed 21:07]
     - State "DONE"       from "TODO"       [2022-12-07 Wed 21:07]
** Cert parsing
*** DONE Parse public key extensions                                  :@code:
    CLOSED: [2022-07-11 Mon 17:54]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:
    - State "DONE"       from "TODO"       [2022-07-11 Mon 17:54]
**** DONE Lemmas for public key extensions parser                     :@code:
     CLOSED: [2022-07-11 Mon 17:54]
     :PROPERTIES:
     :ASSIGNEE: Christa
     :END:
     - State "DONE"       from "TODO"       [2022-07-11 Mon 17:54]
     - Note taken on [2022-06-14 Tue 18:29] \\
       Need to be able to use the OID parser to show that a literal (for RSA PK
       algorithm) is a valid OID. For that, need to move TLV, Length properties to
       avoid cyclic module dependency
** StringPrep
*** WONT Analyze cert. census data for language (unicode)             :@code:
    CLOSED: [2022-06-02 Thu 17:23]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:
    - State "WONT"       from "TODO"       [2022-06-02 Thu 17:23]
    - Note taken on [2022-04-15 Fri 15:41] \\
      Do we need this? Switched focus to case folding, which already does
      normalization for large set of characters already.
      So the info we are pulling from comes from the [[https://datatracker.ietf.org/doc/html/rfc3454#appendix-B.2][RFC]] instead

    We are not planning on supporting /all/ languages supported by Unicode, so
    lets find a subset that covers most / all of our testing data
*** WONT String normalization code generation                         :@code:
    CLOSED: [2022-04-15 Fri 14:40]
    :PROPERTIES:
    :ASSIGNEE: Joy
    :END:

    - State "WONT"       from "TODO"       [2022-04-15 Fri 14:40] \\
      We will use actual tries instead, hoping this will improve performance for
      typechecking and runtime
    Per discussion with Omar, having a function with "trie-like" cases might
    speed up runtime by sharing lookup, and compile time by reducing the number
    of cases
*** MAYBE Custom ordering for UTF8Char                                :@code:
    CLOSED: [2022-06-02 Thu 18:33]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    A custom ordering for UTF8Char may be needed if comparisons (needed for
    checking if a code lands within a certain range) are too slow.

    If we use an ordering other than the obvious translation to Nat, then we
    will want to prove, at least, that it is a total order.
    Probably we also want to prove it coincides with the obvious ordering
*** DONE Define UTF8 spec                                             :@code:
    CLOSED: [2022-03-22 Tue 13:17]
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:
    - State "DONE"       from "TODO"       [2022-03-22 Tue 13:17]
*** TODO Prove StringPrep algorithm is idempotent                     :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

** Presentation
  
*** TODO Note =--sized-types= =--guardedness= inconsistency        :@typeset:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

   See the remark in the documentation [[https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html][here]], and the filed issue [[https://github.com/agda/agda/issues/1209][here]].

   - We only use sized types for the agda-stdlib trie implementation, and
     guardedness for the agda-stdlib IO implementation. We do not mixed guarded
     coinductive and sized inductive types, so the issue should not apply to us.

     That said, since sized types are broken on their own, the ideal solution is
     to roll our own trie implementation.
   
*** TODO Rename grammar properties                                    :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

    The names of properties for the grammar elements should, where possible, be
    named following existing literature on languages.

    | Old name      | New name      |
    |---------------+---------------|
    | =NoConfusion= | =NoConflict=  |
    | =Unambiguous= | =Unique=      |
    | =NonEmpty=    |               |
    | =NonNesting=  | =Unambiguous= |
    |---------------+---------------|
    | =Dig=         | =UInt8=       |

*** TODO Remove postulates, =--allow-unsolved-metas=                  :@code:

*** TODO [#A] Write-up explanation of Aeres architecture              :@code:
    :PROPERTIES:
    :ASSIGNEE: Christa
    :END:

** Building and running
*** TODO Move tests to their own directory                            :@code:

    This will also speed-up typechecking and compilation time during development
* PROJ AERES Paper
** [2/5] Christa

   - [ ] Double-check S3.1.1
   - [ ] Double-check S3.3.6
   - [ ] Finish S4.3 revisions
   - [X] Double-check termination
   - [X] [2/2] ASN1STAR
     - [X] check accuracy of claim that ASN1Star proves mutual correctness wrt
       encoder / decoder
     - [X] contrast unambiguous and uniqueness with non-malleability

       This is not nearly as strong as the non-malleability property of ASN1*,
       because our specifications are not equipped to even *state* the property
       that different bytestring representations of ASN.1 are equal (because the
       bytestring is part of the type, and to even state the property that two
       terms are equal they must have the same type).

       What would have to be done is either make separate, non-indexed datatypes
       capturing the "mere data", write functions that convert the indexed
       specification to the mere data, and prove non-malleability for the
       results (or the mere data could be fields, and we can use lenses)

* Misc Notes

*** 2022 May 31 Tue 20:33

    - serializer for OID, for getSignAlgBS
    - nonnesting for PkAlg
    - postulated public key fields properties

*** 2022 Apr 15 Fri

    - Semantic Checks
      - We should review the specification and proof of each semantic check, to
        make sure that the spec is convincing

        For example
        - SCP18: The check on time just uses booleans, rather than defining an ordering
          on time values
        - CCP7: whether a cert is in a given set (with stringprep)
    - Executable
      - Testing for performance, parsing PEM
      - Returing the remaining crypto checks: PK, Digest, Signature

        For the harness to invoke on an external program
    - Spec improvements
      - Time
        Not as precisely specified as it could be (e.g., leap days, leap seconds
        not covered --- also day ranges for months is inaccurate)
    - String prep
      - It seems to me like idempotency / normalization is the only thing people
        would care about when it comes to the stringprep algorithm

        Its purpose is to give a decidable equivalence relation by giving every
        string a canonical form. If the spec introduces nondeterminism, we are
        no longer formalizing the stringprep algorithm

        To ease reasoning, we can also use lemmas stating no character in the
        image of one mapping is in the domain of a previous mapping
    - Cryptographic checks
      Outsourced to a harness
      - I need to know (from Joy, Omar) what fields need to be checked: for a
        cert, where is the digest, where is the public key
    - Org
      - Joy: update the TODO items that have been assigned to you with the
        results (e.g., analysis of cert data for unicode coverage)
* End

#  LocalWords:  AERES

# Local Variables:
# eval: (flyspell-mode)
# eval: (smartparens-mode)
# End:
