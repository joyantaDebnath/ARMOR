\section{Background and Problem Definition}
In this section, we first present a brief introduction to X.509
certificates and their validation logic. We then present our overarching objective of this paper and the related technical challenges, with our high-level insights to address the challenges.

\subsection{Preliminaries on X.509 CCVL}
The primary component of X.509 PKI is the certificate, a digitally signed document that binds a public key to a specific identity to assure that the certificate holder is indeed the entity it claims to be. Though the X.509 PKI is primarily defined in the X.509 ITU-T Recommendation, RFC 5280 provides additional restrictions and directions to use X.509 certificate standard for the Internet. Particularly, RFC 5280 concentrates on version 3 of the certificate standard and the usage of Certificate Revocation List (CRL) and extensions. 

\subsubsection{Structure of a Certificate and Certificate Chain}
An X.509 certificate comprises three top-level fields: TbsCertificate, SignatureAlgorithm, and SignatureValue. These fields give a high-level structure to the certificate, as shown in Figure 1. The TbsCertificate part contains various information, such as the certificate version, a unique serial number, the validity period, the certificate issuer's name, and the certificate owner's name (i.e., subject). It also includes the public key, the algorithm employed by the issuer for signing the certificate, and a few optional fields like unique identifiers and a sequence of extensions, specifically for version 3 of the X.509 standard. Following the TbsCertificate, the issuer signs the entire TbsCertificate content, generating a signature, denoted as SignatureValue, which is appended to the certificate's end, creating a digitally secure and tamper-proof document. The SignatureAlgorithm field specifies the algorithm used by the certificate issuer or signer for generating the SignatureValue from the TbsCertificate.

A certificate chain, also known as a certification path, is a sequence of X.509 certificates originating from an end-entity certificate (the one being authenticated) and ending with a root certificate. This chain is based on the concept of trust transitivity- if Certificate A is trusted by Certificate B and Certificate B is trusted by Certificate C, then Certificate A is inherently trusted by Certificate C. Each certificate in the chain is signed by the owner of the subsequent certificate, and the process continues until reaching the root certificate. The root certificate is a unique, self-signed certificate issued by a trusted CA, which forms the root of trust in the X.509 PKI.

\subsubsection{Certificate Chain Validation Logic (CCVL)}

Certificate chain validation logic (CCVL) defines the steps to verify the authenticity of a certificate chain. This CCVL involves parsing and checking each certificate in the chain, starting from the end-entity certificate and moving up toward the root certificate.

Here are the notable checks performed in the context of a client validating the certificate chain received from a server. \\
    \textbf{Name Chaining Check:} The validating client checks whether the issuer of the current certificate is the same as the subject of the subsequent certificate. This step confirms that each certificate in the chain was issued by the following certificate in the chain. \\
    \textbf{Validity Period Check:} Each certificate comes with a validity period. The client checks to ensure the certificate is used within its validity period. \\
    \textbf{Signature Verification:} The validating client uses the public key of the subsequent certificate in the chain to verify the digital signature on the current certificate. This step ensures that the certificate has not been tampered. \\
    \textbf{Trust Anchor Check:} The final step is to ensure the client trusts the root certificate. The chain is validated successfully if the root certificate is stored in the client's trust store (i.e., trust anchors). \\
    \textbf{Hostname Verification:} Hostname verification ensures that the server the client connects to is the one it claims to be. This is accomplished by comparing the hostname the client used to initiate the connection with the name bound in the server's certificate. \\
    \textbf{Revocation Check:} The issuer can revoke a certificate before its expiration date due to unexpected events such as private key compromise. The client checks a Certificate Revocation List (CRL) or uses the Online Certificate Status Protocol (OCSP) to ensure the certificate has not been revoked.

The chain validation is successful if all the checks mentioned above and the rest defined in the RFC 5280 specification pass. If any check fails, the validation process stops, and the certificate is deemed untrusted.



\subsection{Objective and Technical Challenges}
In this paper, our overarching objective is to develop a formally verified reference implementation for X.509 CCVL. By formally verifying the implementation, we aim to ensure it adheres to the X.509 CCVL specification with high confidence. This will provide a robust and trustworthy reference that can be used to validate and improve other CCVL implementations, ultimately enhancing the overall security and reliability of X.509 PKI and its applications.

\subsubsection*{Challenges}
There are several challenges to developing a correct (\ie, specification-compliant) X.509 CCVL implementation. In general, interpreting the RFC 5280 specification, outlined in natural language, presents a significant challenge due to inherent inconsistencies, ambiguities, and potential for misinterpretation. Prior studies have also identified these issues, pointing out several problematic clauses in RFC 5280. For instance, there are discrepancies regarding the allowed range of values for certificate serial numbers and ambiguities in the structure of the CRL Distribution Point extension. Moreover, RFC 5280 does not only encompass rules for certificate issuers but also for the applications that validate certificates. This intertwined set of regulations further complicates the specification, making it challenging to determine how client-side CCVL implementations should respond - whether to accept or reject a certificate chain. Hence, extracting unambiguous and consistent rules from this specification for a robust, formally verified implementation is challenging.

Now, we present the additional challenges for our work. \\
\textbf{Parsing Challenges--} The structure of an X.509 certificate, while described in the ASN.1 notation, is eventually serialized based on the X.690 Distinguished Encoding Rules (DER). To make this binary data more human-readable and easier to debug, it is then encoded into the Privacy Enhanced Mail (PEM) format using base64 encoding. Upon receiving such a certificate in PEM format, one must reverse this process to extract and interpret the information stored within. Firstly, the base64 decoding must be applied to convert the textual PEM certificate back into its original binary format. This DER-encoded binary data then needs to be parsed using a DER certificate parser, which extracts all the information from the certificate and transforms it into an intermediate representation for processing the certificate data during subsequent verification checks. 

However, this DER representation of the certificate internally follows a <T, L, V> structure to represent each certificate field, where 'T' denotes the type, 'V' indicates the actual contents, and 'L' signifies the length of the 'V' field. Additionally, the 'V' field can include nested <T, L, V> structures, adding additional layers of complexity to the binary data. Parsing such binary data is challenging since it always requires passing the value of the 'L' field to accurately parse the subsequent 'V' field. In other words, the inherent structure of DER encoding is context-sensitive, and developing an error-free parser for such a context-sensitive language is a complex endeavor. \\
\textbf{Semantic Validation Challenges--} 
Once the certificates have been parsed into intermediate representations, client applications must undertake a series of steps to authenticate the parsed certificates. Initially, a valid certification path should be constructed from the end-user certificate to the root CA certificate. Following this, string canonicalization is performed, a type of string transformation to ensure that all the strings in the certificate are in a normalized format. After these initial stages, the process moves onto semantic validation, a more in-depth verification procedure. During semantic validation, several checks are performed, such as signature verification to authenticate the issuer of the certificate, trusted Certificate Authority (CA) checks to confirm the certificate has been issued by a trusted source, and certificate validity checks, which validate the certificate's date range for when it is valid. Following these comprehensive checks, the application can make an informed decision regarding accepting or rejecting the certificate chain. 

However, each of these steps presents challenges. For example, building a valid chain can be difficult as there can be multiple paths, circular paths, or missed certificates. Converting strings to normalized format is also a complex process since the number of character sets is humongous considering all the languages worldwide. In addition, prior to Signature verification, one needs to carefully parse the contents of the Signature field again to prevent attacks based on a signature forgery. Therefore, while these steps are conceptually straightforward, implementing them in a robust, secure, and efficient manner is a significant challenge. \\
\textbf{Formal Verification Challenges--} 
X.509 CCVL involves cryptographic operations, including public key operations and digital signature verification. These operations are based on mathematical theories and are computationally complex, making them challenging to formally model and verify. In addition, guaranteeing soundness and completeness of the CCVL implementation further intensifies the task. Soundness, ensuring that every certificate chain the process marks as valid is indeed valid according to RFC 5280 specifications, demands a comprehensive approach that leaves no corner case or unusual behavior unchecked, a significant challenge given the complexity of the X.509 standard. Completeness, however, requires the system to confirm the validity of all genuinely valid certificate chains per RFC 5280. Achieving this necessitates an exhaustive exploration of all potential valid states and configurations, a daunting endeavor given the broad parameter space and potential variations in X.509 certificates, chains, and cryptographic procedures.

\subsection{Our Insights} Now, we briefly present our insights on addressing the challenges of developing a formally verified CCVL implementation.

\textbf{Drawing Boundary--} Drawing a clear boundary between the parsing and semantic rules is pivotal in formally verifying X.509 CCVL. However, having a balance is also vital; too many semantic checks incorporated into the parsing process can lead to an overly complex parser while excluding all semantic checks can result in an overly lenient parser. Our strategy lies somewhere in the middle, taking inspiration from the reengineering work by Debath et al. We categorize DER-related rules (including length bound check) as part of the parsing rules, and the rest are left for semantic checks. This approach contributes to a more manageable parser that maintains necessary rigor without becoming overly complex. [Example]

\textbf{Moudlarity--} Adopting a modular approach to implementing the X.509 CCVL can significantly mitigate some of these challenges. The entire process can be broken down into smaller, manageable components or modules. Each module is designed to perform a specific function, such as DER parsing, certificate chain construction, string canonicalization, and semantic checks. Such modularization allows us to precisely specify the requirements for each module and independently establish their correctness. In addition, instead of trying to accomplish everything in a single step, this modularization allows us to undertake the validation task in multiple passes, increasing the simplicity and manageability of the overall process.

\textbf{Specificity--} ??