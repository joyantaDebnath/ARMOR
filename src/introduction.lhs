\section{Introduction}

As digital communication continues to grow, with an increasing dependence on online transactions in fields such as e-commerce, banking, online media, healthcare, and government services, the need for establishing trust in communication is more significant than ever. The \xfon Public Key Infrastructure (PKI)~\cite{rec2005x} is currently the most-used standard for achieving trust, providing a scalable and flexible mechanism for authentication. The fundamental motivation for the \xfon PKI is to enable communicating entities to reliably authenticate each other's identities over insecure networks, thereby enhancing \textit{trust} and eventually helping achieve other security guarantees such as \textit{confidentiality}, \textit{integrity}, and \textit{non-repudiation}. 


\xfon PKI provides a framework for creating, distributing, and verifying digital certificates. This digital certificate containing a public key and the identity of the key's owner is digitally signed by a trusted issuer (\eg, certificate authority or CA) using cryptographic techniques to \textit{bind} the identity to its public key. When the owner provides such a certificate to authenticate itself to another entity, the authenticator must validate the certificate. This certificate validation is a process of verifying that the binding of the identity and the public key contained within it is legitimate, current (\ie, not revoked or expired), and signed by a trusted CA. Such a validation process ensures that only valid and trustworthy certificates are used in digital communications.


Given the pivotal role that \xfon certificate validation plays in securing digital transactions, ensuring its correctness is of utmost importance. Incorrect validation could lead to a system accepting a malicious or invalid certificate, potentially exposing the system to man-in-the-middle (MITM) and impersonation attacks. Previous testing efforts have leveraged methods like \fuzzing~\cite{frank, mucert, nezha, quan2020sadt, chen2023sbdt}, which involves feeding a range of invalid inputs to the system to find vulnerabilities, and \symex~\cite{rfcguided, symcert}, a method of analyzing a program to determine what inputs cause each part of the program to execute. While these methods have been beneficial in identifying numerous vulnerabilities, they often fall short of providing a guarantee of correctness. Though a recent re-engineering effort by Debnath \etal has developed a high-assurance implementation for \xfon certificate validation leveraging \smtsolver~\cite{debnath2021re}, their approach also does not provide formal correctness. However, a formally-verified reference implementation can provide mathematical assurance that the implementation behaves as expected as the requirements of the standard specifications and may set a benchmark for developing other implementations. Hence, there is a clear motivation for \textit{developing a formally-verified reference implementation for \xfon certificate validation}, which is the research gap we address in this paper.

\textbf{Technical Challenges:} Our work has several technical challenges. \textit{Firstly}, the specifications we need to follow are written in natural language (\eg, English) and often unclear and under-specified~\cite{debnath2021re, larisch2022hammurabi, yen2021tools}, making them tricky to interpret correctly. \textit{Secondly}, building a parser to decode the structure of a \der (Distinguished Encoding Rule)~\cite{rec2002x} encoded binary certificate is quite complex due to the \textit{context-sensitive} nature of the certificate's internal grammar~\cite{kaminsky2010pki, debnath2021re}. \textit{Thirdly}, before we can check the parsed certificate for semantic errors, we need to correctly perform some intermediate steps like chain building~\cite{cooper2005rfc, path} and string transformation~\cite{zeilenga2006lightweight}. \textit{Finally}, the daunting task of modeling and demonstrating the correctness of the cryptographic operations can pose a significant challenge, demanding sophisticated mathematical techniques and a deep understanding of the underlying cryptographic principles while ensuring the focus remains on the core certificate validation process.

\textbf{Technical Insights:} Our \textit{first} insight is maintaining a balance between parsing and semantic checks. Drawing ideas from the previous work~\cite{debnath2021re}, we also treat the \der restrictions as part of the parsing rules while delegating the remaining checks to semantic validation. Such methodology facilitates the development of a manageable parser that does not compromise on the necessary rigor. \textit{Furthermore}, we leverage a modular implementation, breaking the process into distinct modules. Such an approach aids in simplifying the overall certificate validation process, as it allows for the detailed specification of the requirements and establishes the correctness of each module independently. \textit{Finally}, recognizing that not all aspects of the \xsno \der~\cite{rec2002x} and RFC-5280~\cite{cooper2008internet} specifications are used in practice, we primarily focus on the most commonly employed fragments of these standards, thereby ensuring the relevance and usability of our formally-verified implementation.

\textbf{Our Approach:} Our formally-verified implementation, \armor, is organized into four main modules: the \driver, \parser, \stringtransformer, and \semantic. The \driver, implemented in \python, processes certificate inputs provided in a \pem (Privacy Enhanced Mail)~\cite{balenson1993privacy} file format, pre-assuming an ordered sequence of end-entity and CA certificates constituting a valid certification path. We leverage \agda~\cite{bove2009brief}, a dependently typed functional programming language and theorem prover, to formally verify the \parser, \stringtransformer, and \semantic modules. We demonstrate both \soundness and \completeness in our verification step as overarching properties. \soundness guarantees that when \armor accepts a certificate chain, the formal specification will also. Conversely, \completeness ensures that if the formal specification accepts a certificate chain, \armor does too. By attaining both properties, we confirm that our implementation performs precisely as stipulated in the specification.


\textbf{Evaluation and Notable Findings:} We aim to evaluate \armor's correctness in interpreting the specification, its performance as a benchmark, and its runtime and memory overhead. Therefore, we conduct differential testing against $11$ open-source \xfon implementations. Our evaluation uses a dataset of $2$ million certificates randomly selected from a snapshot of $1.5$ billion real certificates gathered from the \censys~\cite{censys} certificate repository. Our analysis shows that \armor enforces stricter validation rules compared to most libraries, rejecting $10,222$ certificate chains accepted by other libraries due to their violations of RFC-5280 requirements. \armor also showed no discrepancies compared to high-assurance implementation like \ceres~\cite{debnath2021re}. In terms of runtime and memory overhead, \armor consumes a considerable amount of memory compared to other libraries, yet its execution time is competitive, especially when compared to \ceres. These results suggest that despite not outperforming the \cpp libraries (\eg, \openssl~\cite{openssl}, \gnutls~\cite{gnutls}, \boringssl~\cite{boringssl}, \mbedtls~\cite{mbedtls}, \wolfssl~\cite{wolfssl}, \matrixssl~\cite{matrixssl}) regarding memory and runtime, \armor's correctness guarantees and reasonable runtime make it a viable choice for real-world scenarios.

\textbf{Our Contributions:} Our work presents significant contributions to the field of \xfon PKI, as stated below.

\begin{enumerate}
    \item We have articulated a formal specification of the \xfon standard using our unique interpretation, leading to a better understanding and clear representation of the standard. 

    \item We have developed \armor, an implementation that accurately conforms to this formal specification, providing a correct and specification-compliant solution for certificate validation.


    \item Our evaluation of \armor is extensive and comprehensive, as it has been tested against $11$ open-source \xfon libraries, demonstrating its reasonable performance and effectiveness in practice.
\end{enumerate}