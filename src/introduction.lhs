\section{Introduction}

As digital communication continues to grow, with an increasing dependence on online transactions in fields such as e-commerce, banking, online media, healthcare, and government services, the need for establishing trust in communication is more significant than ever. The X.509 Public Key Infrastructure (PKI)~\cite{rec2005x} is currently the most-used standard for achieving trust, providing a scalable and flexible mechanism for authentication. The fundamental motivation for the X.509 PKI is to enable communicating entities to reliably authenticate each other's identities over insecure networks, thereby enhancing trust and eventually helping achieve other security guarantees such as confidentiality, integrity, and non-repudiation. 


X.509 PKI provides a framework for creating, distributing, and verifying digital certificates. This digital certificate containing a public key and the identity of the key's owner is digitally signed by a trusted issuer (certificate authority, or CA) using cryptographic techniques to bind the identity to its public key. When the owner provides such a certificate to authenticate itself to another entity, the authenticator must validate the certificate. This certificate validation is a process of verifying that the binding of the identity and the public key contained within it is legitimate, current (not revoked or expired), and signed by a trusted CA. Such a validation process ensures that only valid and trustworthy certificates are used in digital communications.


Given the pivotal role that X.509 certificate validation plays in securing digital transactions, ensuring its correctness is of utmost importance. Incorrect validation could lead to a system accepting a malicious or invalid certificate, potentially exposing the system to man-in-the-middle (MITM) and impersonation attacks. Previous testing efforts have leveraged methods like fuzzing~\cite{frank, mucert, nezha, quan2020sadt, chen2023sbdt}, which involves feeding a range of invalid inputs to the system to find vulnerabilities, and symbolic execution~\cite{rfcguided, symcert}, a method of analyzing a program to determine what inputs cause each part of the program to execute. While these methods have been beneficial in identifying numerous vulnerabilities, they often fall short of providing a guarantee of correctness. Though a recent re-engineering effort by Debnath et al. has developed a high-assurance implementation for X.509 certificate validation leveraging SMT solver~\cite{debnath2021re}, their approach also does not provide formal correctness. However, a formally-verified implementation can provide mathematical assurance that the implementation behaves as expected as the requirements of the standard specifications and may set a benchmark for developing other implementations. Hence, there is a clear motivation for developing a formally-verified implementation for X.509 certificate validation, which is the research gap we address in this paper.

\textbf{Technical Challenges:} Our work on developing a formally-verified X.509 certificate validation implementation has several technical challenges. Firstly, the specifications we need to follow are written in natural language and often unclear and under-specified~\cite{debnath2021re, larisch2022hammurabi, yen2021tools}, making them tricky to interpret correctly. Secondly, building a parser to decode the structure of a DER (Distinguished Encoding Rule)~\cite{rec2002x} encoded binary certificate is quite complex due to the context-sensitive nature of the certificate's internal grammar~\cite{kaminsky2010pki, debnath2021re}. Thirdly, before we can check the parsed certificate for semantic errors, we need to correctly perform some intermediate steps like chain building~\cite{cooper2005rfc, path} and string normalization~\cite{zeilenga2006lightweight}. Finally, the daunting task of modeling and demonstrating the correctness of the cryptographic operations can pose a significant challenge, demanding sophisticated mathematical techniques and a deep understanding of the underlying cryptographic principles while ensuring the focus remains on the core certificate validation process.

\textbf{Technical Insights:} Our first insight is maintaining a balance between parsing and semantic checks. Drawing ideas from the previous work~\cite{debnath2021re}, we also treat the DER restrictions as part of the parsing rules while delegating the remaining checks to semantic validation. Such methodology facilitates the development of a manageable parser that does not compromise on the necessary rigor. Furthermore, we leverage a modular implementation, breaking the process into distinct modules. Such an approach aids in simplifying the overall certificate validation process, as it allows for the detailed specification of the requirements and establishes the correctness of each module independently. Finally, recognizing that not all aspects of the X.690 DER~\cite{rec2002x} and RFC 5280~\cite{cooper2008internet} specifications are used in practice, we primarily focus on the most commonly employed fragments of these standards, thereby ensuring the relevance and usability of our formally verified implementation.

\textbf{Our Approach:} Our formally-verified implementation, ARMOR, is organized into four main modules: the driver, parser, string transformer, and semantic checker. The driver, implemented in Python, processes certificate inputs provided in a single PEM~\cite{balenson1993privacy} file, pre-assuming an ordered sequence of end-entity and CA certificates constituting a valid certification path. We leverage Agda~\cite{bove2009brief}, a dependently typed functional programming language and theorem prover, to formally verify the parser, string transformer, and semantic checker modules. We demonstrate both soundness and completeness in our verification step as overarching properties. Soundness guarantees that when ARMOR accepts a certificate chain, the formal specification will also. Conversely, completeness ensures that if the formal specification accepts a certificate chain, ARMOR does too. By attaining soundness and completeness, we confirm that our implementation performs precisely as stipulated in the specification.


\textbf{Evaluation and Notable Findings:} We aim to evaluate ARMOR's correctness in interpreting the specification, its performance as a benchmark, and its runtime and memory overhead. Therefore, we conduct differential testing against 11 open-source X.509 implementations. Our evaluation uses a dataset of 2 million certificates randomly selected from a snapshot of 5 billion real certificates gathered from the Censys~\cite{censys} certificate repository. Our analysis shows that ARMOR enforces stricter validation rules compared to most libraries, rejecting 10,222 certificate chains accepted by other libraries due to their violations of RFC 5280 requirements. ARMOR also showed no discrepancies compared to high-assurance implementation like CERES~\cite{debnath2021re}. In terms of runtime and memory overhead, ARMOR consumes a considerable amount of memory compared to other libraries, yet its execution time is competitive, especially when compared to CERES. These results suggest that despite not outperforming the C libraries (e.g., OpenSSL~\cite{openssl}, GnuTLS~\cite{gnutls}, BorignSSL~\cite{boringssl}, Mbed TLS~\cite{mbedtls}, wolfSSL~\cite{wolfssl}, MatrixSSL~\cite{matrixssl}) regarding memory and runtime, ARMOR's correctness guarantees and reasonable runtime make it a viable choice for real-world scenarios.

\textbf{Our Contributions:} Our work presents significant contributions to the field of X.509 PKI, as stated below.

\begin{enumerate}
    \item We have articulated a formal specification of the X.509 standard using our unique interpretation, leading to a better understanding and clear representation of the standard. 

    \item We have developed ARMOR, an implementation that accurately conforms to this formal specification, providing a correct and specification-compliant solution for certificate validation.


    \item Our evaluation of ARMOR is extensive and comprehensive, as it has been tested against 11 open-source X.509 libraries, demonstrating its reasonable performance and effectiveness in real-world scenarios.
\end{enumerate}